{"description": "Binary Heap Implementation", "tags": "zeek, zeek.org, BinaryHeap", "version": "master", "depends": null, "test_cmd": null, "build_cmd": null, "url": "https://github.com/jmellander/BinaryHeap", "summary": null, "script_dir": "scripts", "plugin_dir": null, "readme": "# BinaryHeap\n\nThe goal of this package is to provide a binary heap package for Zeek that can be used in multiple applications:\n\n\tPriority queue: can be efficiently implemented using a binary heap in O(logn) time.\n\tIncremental sorting: can be performed using a binary heap.\n\tOrder Statistics: efficiently find the kth smallest (or largest) elements in an array.\n\nThis implementation includes the following main functions:\nCreate Heap with compare function\n\tBuilt in MinHeap & MaxHeap functions\nAdd to Heap\nDelete from Heap\nModify Item in Heap\nReturn root of Heap\nPeek at root\nReplace root with new item and rebalance.\n\nAnd a number of utility functions\nSize of Heap\nReturn value of specific item by key\nDetermine if item by key is in Heap\n\nData structures & Functions\n\nBasic user item:\n\n```\ntype Item: record {\n    key: string &optional;\nval: double &optional;\n};\n```\n\nThe heap definition:\n\n```\ntype Heap: record {\nheap: table[count] of Item;     # The binary heap itself\n               idx: table[string] of count;    # map of key to location in binary heap\n               cmp: function(a: double, b:double): double;\n};\n```\n\nCreate a Heap:\n\n```\nInit: function(cmp: function(a: double, b:double): double): Heap;\n```\nThis function returns an empty Heap record, initialized.  cmp is the comparison function to determine whether to swap items.  Not usually used.\n \n```\nMinHeap: function(): Heap;\n```\nThis calls Init with an appropriate cmp() function that structures the Heap as a MinHeap.\n\n```\nMaxHeap: function(): Heap;\n```\nCreates a MaxHeap ala MinHeap\n\n```\nAdd: function(a: Heap, var: Item): bool;\n```\nAdds an Item to Heap, returns F if var$key already exists, T upon success\n\n```\nModify: function(a: Heap, var: Item): bool;\n```\nModifies an Item already in Heap to var$val, returns F if var$key doesn\u2019t exist, T upon success\n\n```\nUpdate:function(a: Heap, var: Item);\n```\nUpdates or adds an Item in heap.  If var$key exists, add var$item to current value,\nOtherwise add Item to Heap\n\n```\nDelete: function(a: Heap, var: Item): bool;\n```\nDelete Item var$key from Heap, var$val unused.  Return T is var$key was in Heap, otherwise F\n\n```\nPeek: function(a: Heap): Item;\n```\nReturns Item at root of Heap, without deleting from Heap, or empty Item if Heap is empty\n\n```\nRoot: function(a: Heap): Item;\n```\nReturns Item at root of Heap, and deletes it from Heap, or empty Item if Heap is empty\n\n```\nRootAndAdd: function(a: Heap, var: Item): Item;\n```\nThis function combines in an efficient way the Root() function, and the Add() function\n\n```\nIsIn: function(a: Heap, var: Item): bool;\n```\nReturns T or F depending on whether var$key is in the heap\n\n```\nSize: function(a: Heap): count;\n```\nReturns number of Items in Heap\n\n```\nValue: function(a: Heap, var: Item): Item;\n```\nReturns Item that corresponds to var$key, or empty Item if non-existant\n\n\nUsage Example\n\n```\nevent bro_init()\n\t{\n\t# Randomize\n\tsrand(double_to_count(time_to_double(current_time())));\n\n\t# Initialize a MinHeap\n\n\tlocal MyHeap = BinaryHeap::MaxHeap();\n\tlocal item:BinaryHeap::Item;\n\n\t# Lets add random values & keys\n\tlocal i=1000;\n\twhile (i > 0)\n\t\t{\n\t\titem = [$val=rand(100000) + 0.0, $key=md5_hash(rand(1000000))];\n\t\tBinaryHeap::Add(MyHeap, item);\n\t\t--i;\n\t\t}\n\n\t# Now print them out, highest first\n\twhile (BinaryHeap::Size(MyHeap) > 0)\n\t\t{\n\t\titem=BinaryHeap::Root(MyHeap);\n\t\tprint item;\n\t\t}\n\texit(0);\n\t}\n```\n\n\n"}